https://chat.deepseek.com/share/w6zz8rbudx8y6oldui


# Network Optimization for Frontend System Design

## 1. Critical Rendering Path (CRP)

### What is CRP?
The Critical Rendering Path is the sequence of steps the browser takes to convert HTML, CSS, and JavaScript into pixels on the screen. Optimizing CRP means minimizing the time to **First Contentful Paint (FCP)** and **Largest Contentful Paint (LCP)**.

### How Resources Affect CRP
- **HTML**: Parsed incrementally, can block rendering if not delivered quickly
- **CSS**: Render-blocking until parsed and constructed into CSSOM
- **JS**: Parser-blocking (unless `async`/`defer`), can also trigger style recalc/layout
- **Fonts**: Fonts with `font-display: block` or `swap` can cause FOIT/FOUT
- **Images**: Not render-blocking but affect LCP, especially hero images

### 14KB First Packet (Initial Congestion Window)
```html
<!-- Critical: Fit essential HTML/CSS in first 14KB -->
<!DOCTYPE html>
<html>
<head>
  <style>
    /* Above-the-fold CSS (inlined) */
    .header, .hero, .nav { display: block; }
  </style>
</head>
<body>
  <!-- Above-the-fold HTML -->
  <header class="header">...</header>
  <main class="hero">...</main>
</body>
</html>
```
**Why it matters**: TCP's initial congestion window allows only ~14KB (10 packets × 1460 bytes) in the first round trip. Delivering critical content in this window improves FCP.

### Tradeoffs: Inlining vs External
```javascript
// Example: Inline critical CSS for FCP, load rest asynchronously
const criticalCSS = `
  .header, .hero { opacity: 1; }
  .lcp-image { background: #f0f0f0; }
`;
const nonCriticalCSS = document.createElement('link');
nonCriticalCSS.rel = 'stylesheet';
nonCriticalCSS.href = '/styles.css';
nonCriticalCSS.media = 'print';
nonCriticalCSS.onload = () => { nonCriticalCSS.media = 'all'; };
```

**Decision Framework**:
- **Inline**: Critical CSS, minimal JS for hydration
- **External**: Non-critical CSS/JS, large resources
- **Rule**: Inline ≤ 1-2KB, external > 2KB

---

## 2. Minimizing Network Requests

### Why Fewer Requests Matter
Each request has overhead:
- **TCP handshake**: 1 RTT
- **TLS 1.3**: 1 RTT (0-RTT with session resumption)
- **HTTP/1.1 head-of-line blocking**: Sequential requests
- **Total**: 2-3 RTTs per new connection

### Techniques
```html
<!-- 1. Inlining small critical assets -->
<style>/* 1KB critical CSS */</style>
<script>/* 500B hydration script */</script>

<!-- 2. Base64 encoding (use sparingly!) -->
<!-- Good: <1KB icons, data URLs for small dynamic images -->
<!-- Bad: Large images, frequently changing assets -->
<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAi..." />

<!-- 3. SVG sprites vs Icon fonts -->
<!-- SVG: Better accessibility, sharp rendering, smaller file size -->
<svg><use href="/sprite.svg#icon-home"></use></svg>

<!-- 4. CSS sprites (legacy, less needed with HTTP/2) -->
.icon { background-image: url(/sprites.png); }
.icon-home { background-position: 0 0; }
```

### HTTP/2 & HTTP/3 Tradeoffs
- **HTTP/2**: Multiplexing reduces need for bundling/spriting
- **HTTP/3**: QUIC eliminates head-of-line blocking, faster connection setup
- **Modern approach**: Balance between many small files (cache efficiency) and bundling (request overhead)

---

## 3. JavaScript Loading Strategies

### Script Loading Comparison
```html
<!-- Blocking (default) - pauses parsing, executes immediately -->
<script src="critical.js"></script>

<!-- Defer - loads in parallel, executes after parsing -->
<script src="app.js" defer></script>

<!-- Async - loads in parallel, executes when loaded (order not guaranteed) -->
<script src="analytics.js" async></script>

<!-- Module - behaves like defer by default -->
<script type="module" src="main.js"></script>
```

### Impact on Performance
| Type | Parsing Blocked | Execution Timing | Use Case |
|------|----------------|------------------|----------|
| Blocking | Yes | Immediately | Critical path, small scripts |
| Defer | No | After parsing | Application code, dependencies |
| Async | No | When loaded | Analytics, non-essential scripts |

### Best Practices for Large Apps
```javascript
// Dynamic imports for code splitting
const loadFeature = async () => {
  const module = await import('./heavy-feature.js');
  module.init();
};

// Intersection Observer for lazy loading
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      import('./component.js');
      observer.unobserve(entry.target);
    }
  });
});
```

---

## 4. Avoiding Redirects

### Why Redirects Hurt Performance
```
Initial Request → 301/302 → Second Request → Resource
    │                   │                   │
    └── DNS + TCP       └── DNS + TCP       └── Content
    └── TLS             └── TLS             
    └── Request                            Total: ~2× RTTs
```

### HSTS Implementation
```nginx
# nginx configuration
add_header Strict-Transport-Security 
  "max-age=31536000; includeSubDomains; preload";
```

**Benefits**:
- Eliminates HTTP→HTTPS redirect (saves 1 RTT)
- Prevents SSL-stripping attacks
- Chrome preload list for first visits

### Mobile Considerations
- **Cold start**: 3G networks amplify redirect costs (200-300ms per redirect)
- **Solution**: Serve HTTPS directly, use HSTS, implement App Links/Universal Links

---

## 5. Resource Hinting

### Resource Hints Overview
```html
<!-- DNS prefetch - resolves DNS early -->
<link rel="dns-prefetch" href="https://api.example.com">

<!-- Preconnect - establishes TCP+TLS connection -->
<link rel="preconnect" href="https://fonts.googleapis.com">

<!-- Preload - fetches critical resource early -->
<link rel="preload" href="hero-image.webp" as="image" type="image/webp">

<!-- Prefetch - fetches for next navigation -->
<link rel="prefetch" href="/next-page.html" as="document">

<!-- Prerender - renders entire page in background -->
<link rel="prerender" href="/checkout">
```

### When to Use Each
1. **`dns-prefetch`**: External domains (CDNs, APIs, fonts)
2. **`preconnect`**: Critical third-party origins (Google Fonts, analytics)
3. **`preload`**: Critical first-party resources (hero images, fonts, CSS)
4. **`prefetch`**: Likely next-page resources
5. **`prerender`**: High-confidence user actions (checkout after cart)

### Real-World Example
```html
<head>
  <!-- Preconnect to critical origins -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Preload LCP image -->
  <link rel="preload" as="image" href="hero.webp" type="image/webp">
  
  <!-- Preload critical font -->
  <link rel="preload" as="font" href="font.woff2" type="font/woff2" crossorigin>
</head>
```

---

## 6. Resource Hinting Priority

### `fetchpriority` Attribute
```html
<!-- High priority for LCP candidate -->
<img src="hero.jpg" fetchpriority="high" alt="Hero image">

<!-- Low priority for below-the-fold images -->
<img src="avatar.jpg" fetchpriority="low" alt="User avatar">

<!-- Auto (default) - browser decides -->
<link rel="stylesheet" href="styles.css" fetchpriority="auto">
```

### Browser Priority System
```
Highest (0): Inline blocking scripts, synchronous XHR
High (1): CSS, fonts, critical images, document
Medium (2): Scripts, images, async scripts
Low (3): Non-critical images, prefetch resources
```

### Impact on Web Vitals
```javascript
// Monitoring priority hints
const entries = performance.getEntriesByType('resource');
entries.forEach(entry => {
  console.log(`${entry.name}: ${entry.fetchPriority}`);
});
```

**Optimization**: Assign `high` to LCP elements, `low` to offscreen images.

---

## 7. Early Hints (HTTP 103)

### What are Early Hints?
Server can send preliminary HTTP 103 responses while preparing full response.

```nginx
# nginx configuration
location / {
  early_hints on;
  early_hints_header "Link";
  # Send hints for critical resources
  add_header Link "</style.css>; rel=preload; as=style";
}
```

### Performance Impact
```
Timeline:
0ms: Request → Server
50ms: 103 Early Hints → Client (starts preloading)
200ms: 200 OK + HTML → Client
```

**Improvement**: Can reduce LCP by 200-300ms when preloading critical subresources.

### Limitations
- Requires HTTP/2 or HTTP/3
- Browser support: Chrome/Edge only (as of 2024)
- Only supports `preload` and `preconnect` hints

---

## 8. HTTP Protocol Upgrades

### Protocol Comparison
| Feature | HTTP/1.1 | HTTP/2 | HTTP/3 |
|---------|----------|--------|--------|
| Multiplexing | No | Yes | Yes |
| Head-of-line blocking | Yes (TCP) | Yes (TCP) | No (QUIC) |
| Server push | No | Yes | Yes |
| Connection setup | 2-3 RTTs | 2-3 RTTs | 0-1 RTT |
| Encryption | Optional | Required | Built-in |

### Frontend Implications
```javascript
// HTTP/2 Server Push (declarative via Link headers)
res.setHeader('Link', '</style.css>; rel=preload; as=style');

// HTTP/3 benefits for mobile
// - 0-RTT for repeat visitors
// - Better multiplexing over lossy networks
```

### Real-World Migration
```nginx
# nginx config supporting all protocols
server {
  listen 443 ssl http2;
  listen 443 quic reuseport;
  
  ssl_protocols TLSv1.2 TLSv1.3;
  add_header Alt-Svc 'h3=":443"; ma=86400';
}
```

**Key Insight**: HTTP/3 provides biggest gains for high-latency, mobile, or international users.

---

## 9. Compression

### Gzip vs Brotli Comparison
```nginx
# nginx compression configuration
gzip on;
gzip_types text/css application/javascript image/svg+xml;
gzip_vary on;

# Brotli (better compression)
brotli on;
brotli_types text/css application/javascript image/svg+xml;
brotli_static on;  # Pre-compressed files
```

| Metric | Gzip | Brotli |
|--------|------|--------|
| Compression ratio | ~70% | ~75-85% |
| CPU usage | Low | Medium-High |
| Browser support | Universal | Modern browsers |
| Best for | Dynamic content | Static content |

### Asset-Specific Strategies
```javascript
// Express.js compression middleware
const compression = require('compression');
const express = require('express');

const app = express();
app.use(compression({
  level: 6,  // gzip level
  threshold: 1024,  // Only compress >1KB
  filter: (req, res) => {
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  }
}));
```

**Optimization Tips**:
- Pre-compress static assets with Brotli 11
- Use CDN for dynamic compression
- Don't compress already compressed formats (JPEG, PNG, WebP)

---

## 10. HTTP Caching

### Cache-Control Directives
```http
# Ideal for static assets
Cache-Control: public, max-age=31536000, immutable

# For frequently changing resources
Cache-Control: public, max-age=3600, stale-while-revalidate=86400

# Private user data
Cache-Control: private, max-age=600

# Never cache
Cache-Control: no-store, no-cache, must-revalidate
```

### Caching Strategies
```javascript
// Express.js caching headers
app.use('/static', express.static('public', {
  maxAge: '1y',
  immutable: true,
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache');
    }
  }
}));
```

### Cache Invalidation Patterns
```html
<!-- 1. Fingerprinting -->
<script src="app.a1b2c3.js"></script>

<!-- 2. Version query -->
<link href="/styles.css?v=2.0.0" rel="stylesheet">

<!-- 3. CDN purge APIs -->
// Example: Cloudflare API
fetch('https://api.cloudflare.com/client/v4/zones/{zone_id}/purge_cache', {
  method: 'POST',
  body: JSON.stringify({ files: ['/app.js'] })
});
```

### Strong vs Weak Validation
```http
# Strong validation (exact match)
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# Weak validation (semantic match)
ETag: W/"0815"
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

---

## 11. Service Worker Caching

### Service Worker Strategies
```javascript
// Cache-first for static assets
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(cached => cached || fetch(event.request))
  );
});

// Network-first for dynamic content
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .catch(() => caches.match(event.request))
    );
  }
});

// Stale-while-revalidate pattern
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open('runtime').then(cache => {
      return cache.match(event.request).then(cached => {
        const fetched = fetch(event.request).then(response => {
          cache.put(event.request, response.clone());
          return response;
        });
        return cached || fetched;
      });
    })
  );
});
```

### Offline Support
```javascript
// Install phase: cache critical assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v1').then(cache => 
      cache.addAll(['/', '/styles.css', '/app.js'])
    )
  );
});

// Activation: clean up old caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(keys =>
      Promise.all(keys
        .filter(key => key !== 'v1')
        .map(key => caches.delete(key))
      )
    )
  );
});
```

### Update Strategy
```javascript
// Version-based cache busting
const CACHE_VERSION = 'v2';
const urlsToCache = [
  '/',
  `/styles.${HASH}.css`,
  `/app.${HASH}.js`
];

// SkipWaiting for immediate updates
self.addEventListener('install', event => {
  self.skipWaiting();
});

// Claim clients for immediate control
self.addEventListener('activate', event => {
  event.waitUntil(clients.claim());
});
```

---

## 12. Additional Optimization Techniques

### CDN and Edge Caching
```javascript
// Example: Cloudflare Workers for edge logic
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const url = new URL(request.url);
  
  // Edge caching with revalidation
  const cache = caches.default;
  let response = await cache.match(request);
  
  if (!response) {
    response = await fetch(request);
    
    // Cache HTML for 5 minutes, JS/CSS for 1 year
    if (url.pathname.endsWith('.html')) {
      response = new Response(response.body, {
        headers: { 'Cache-Control': 'max-age=300' }
      });
    }
    
    event.waitUntil(cache.put(request, response.clone()));
  }
  
  return response;
}
```

### Image Optimization
```html
<!-- Responsive images with modern formats -->
<picture>
  <source 
    srcset="hero.webp 1200w, hero-800.webp 800w"
    type="image/webp"
    sizes="(max-width: 600px) 100vw, 50vw">
  <source 
    srcset="hero.jpg 1200w, hero-800.jpg 800w"
    type="image/jpeg"
    sizes="(max-width: 600px) 100vw, 50vw">
  <img src="hero.jpg" alt="Hero" loading="lazy">
</picture>

<!-- Lazy loading with intersection observer -->
<img 
  src="placeholder.jpg" 
  data-src="image.jpg" 
  loading="lazy" 
  class="lazy-load"
  alt="Description">

<script>
document.addEventListener('DOMContentLoaded', () => {
  const lazyImages = document.querySelectorAll('.lazy-load');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  });
  
  lazyImages.forEach(img => observer.observe(img));
});
</script>
```

### Code Splitting and Dynamic Imports
```javascript
// Route-based splitting (React Router + React.lazy)
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}

// Component-level splitting
const HeavyChart = React.lazy(() => 
  import('./components/Chart').then(module => ({
    default: module.Chart
  }))
);
```

### API Batching and GraphQL
```javascript
// REST batching pattern
async function batchRequests(endpoints) {
  const batchId = Date.now();
  const response = await fetch('/api/batch', {
    method: 'POST',
    body: JSON.stringify({
      batchId,
      requests: endpoints.map(url => ({ url }))
    })
  });
  return response.json();
}

// GraphQL optimization
const query = `
  query GetProductPage($id: ID!) {
    product(id: $id) {
      name
      price
      images(size: "medium") { url }
      reviews(limit: 5) { text, rating }
    }
    recommendations(productId: $id) {
      name
      price
    }
  }
`;

// Connection reuse with HTTP/2
const keepAliveAgent = new https.Agent({
  keepAlive: true,
  maxSockets: 100,
  maxFreeSockets: 10,
  timeout: 60000
});
```

---

## 13. System Design Interview Perspective

### Explaining Network Optimization
```
Interview Framework:
1. Identify bottlenecks (use Web Vitals as guide)
2. Propose layered solutions (client → edge → origin)
3. Discuss tradeoffs (complexity vs benefit)
4. Mention monitoring and iteration
```

### Web Vitals Impact
```javascript
// Monitoring performance
const reportWebVitals = (metric) => {
  console.log(metric);
  // Send to analytics
  if (metric.name === 'LCP') {
    analytics.send('web-vital', {
      name: 'LCP',
      value: metric.value,
      rating: metric.rating
    });
  }
};

// Performance budget
const BUDGETS = {
  FCP: 1800,    // ≤ 1.8s
  LCP: 2500,    // ≤ 2.5s
  INP: 200,     // ≤ 200ms
  CLS: 0.1      // ≤ 0.1
};
```

### Common Architecture Diagram
```
User → [CDN Edge] → [Load Balancer] → [Origin Server]
       │           │                  │
       ├─Cache────┤                  ├─Compression
       ├─SSL/TLS──┤                  ├─Minification
       ├─HTTP/3───┤                  └─API Gateway
       └─WAF──────┘

Frontend Layers:
1. Service Worker (offline, caching)
2. Browser Cache (memory/disk)
3. Preload/Preconnect hints
4. Code splitting
5. Lazy loading
```

### Tradeoffs and Mistakes

**Common Tradeoffs**:
1. **Inlining vs caching**: Inlining improves FCP but hurts cache efficiency
2. **Bundling vs HTTP/2**: Bundling reduces requests but increases cache invalidation cost
3. **Preload vs bandwidth**: Over-preloading can starve critical resources

**Common Mistakes**:
```html
<!-- 1. Lazy loading above-the-fold content -->
<img src="hero.jpg" loading="lazy">  <!-- Bad! -->

<!-- 2. Missing CORS on preloaded fonts -->
<link rel="preload" href="font.woff2" as="font">  <!-- Missing crossorigin -->

<!-- 3. Cache-busting everything -->
<script src="app.js?v=123"></script>  <!-- Loses cache benefits -->

<!-- 4. Blocking scripts in head -->
<script src="analytics.js"></script>  <!-- Should be async -->
```

### Interview Response Structure
```
1. "For network optimization, I focus on three phases:
   - Connection (HTTP/3, preconnect, Early Hints)
   - Transfer (compression, caching, minification)
   - Rendering (CRP optimization, lazy loading)"

2. "I prioritize based on Web Vitals:
   - FCP: Inline critical CSS, preload fonts
   - LCP: Priority hints for hero images, preload key requests
   - INP: Code splitting, worker offloading"

3. "I validate with real-user monitoring and
   adjust strategies based on network conditions"
```

### Real-World Example: E-commerce Product Page
```javascript
// Network optimization plan for product page
const optimizations = {
  critical: [
    'Inline above-the-fold CSS',
    'Preload hero image (WebP/AVIF)',
    'Preconnect to CDN and API',
    'Load core JS with defer'
  ],
  progressive: [
    'Lazy load product images',
    'Split review component',
    'Prefetch cart page',
    'Cache API responses'
  ],
  monitoring: [
    'Set LCP budget: 2.5s',
    'Monitor cache hit ratio',
    'Track bundle size growth',
    'Alert on 3rd-party slowdowns'
  ]
};
```

This comprehensive approach balances immediate performance wins with sustainable architecture, addressing both user experience and development maintainability.