Below content is from here:

https://chat.deepseek.com/share/s4a3mna9bot1nulq1y

Refer:

https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF
https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#controlling_third-party_cookies_with_samesite
https://portswigger.net/web-security/csrf

--------


# Cross-Site Request Forgery (CSRF): Comprehensive Guide for Frontend System Design

## 1. What CSRF Is and How It Works

**CSRF (Cross-Site Request Forgery)** is an attack where a malicious website tricks a user's browser into making unauthorized requests to a legitimate website where the user is already authenticated. The browser automatically includes cookies/credentials, making it seem like a legitimate request from the user.

### **Step-by-Step Attack Flow:**
```
Step 1: User logs into Bank.com
┌─────────────┐     POST /login        ┌─────────────┐
│   Browser   │ ──────────────────────> │   Bank.com  │
│             │    (creates session)    │             │
│             │ <────────────────────── │             │
│             │    Set-Cookie: session=abc123        │
└─────────────┘                         └─────────────┘

Step 2: User visits malicious site (Evil.com)
┌─────────────┐     GET Evil.com       ┌─────────────┐
│   Browser   │ ──────────────────────> │   Evil.com  │
│             │                         │             │
│             │ <────────────────────── │             │
│             │  <form action="Bank.com/transfer">   │
│             │  <input type="hidden" name="to" value="hacker">
└─────────────┘                         └─────────────┘

Step 3: Malicious site triggers request to Bank.com
┌─────────────┐     POST Bank.com/transfer ┌─────────────┐
│   Browser   │ ──────────────────────────> │   Bank.com  │
│             │    Cookie: session=abc123   │             │
│             │    to=hacker&amount=1000    │             │
│             │                             │             │
│             │ <────────────────────────── │             │
│             │     Transfer Successful!    │             │
└─────────────┘                             └─────────────┘
```

### **Key Characteristics:**
- **Victim**: User who is logged into the target site
- **Attack Vector**: Malicious site the user visits
- **Execution**: Browser automatically sends stored cookies
- **Impact**: Unauthorized actions performed on user's behalf

## 2. Why Browsers Are Vulnerable to CSRF

### **The Cookie Problem:**
```javascript
// How cookies work in HTTP requests
const request = {
  method: 'POST',
  url: 'https://bank.com/transfer',
  headers: {
    'Cookie': 'session=abc123; user=johndoe'  // AUTOMATICALLY ADDED
  },
  body: 'to=hacker&amount=1000'
};

// Browser automatically includes ALL cookies for that domain
// No JavaScript needed - happens by default
```

### **Browser Behavior That Enables CSRF:**

1. **Automatic Cookie Inclusion:**
   ```http
   # Request from any site to Bank.com includes Bank.com cookies
   GET https://bank.com/transfer?to=hacker&amount=1000
   Cookie: session=abc123  # Added automatically!
   ```

2. **Same-Origin Policy Doesn't Block Requests:**
   - SOP blocks reading *responses* from different origins
   - SOP does **NOT** block *sending* requests to different origins
   - The malicious site can't read the response, but the damage is done

3. **Stateless HTTP Protocol:**
   ```http
   # HTTP doesn't track request origin
   POST /transfer HTTP/1.1
   Host: bank.com
   Cookie: session=abc123
   
   # Server sees: "Legitimate user wants to transfer money"
   # No way to know request came from Evil.com
   ```

## 3. Real-World Examples of CSRF Attacks

### **Example 1: Bank Transfer**
```html
<!-- Evil.com page -->
<img src="https://bank.com/transfer?to=hacker&amount=1000" 
     width="0" height="0" style="display:none">

<!-- OR -->
<form id="csrf-form" action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="hacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

### **Example 2: Email Settings Change**
```html
<!-- Change email to attacker's email -->
<form action="https://gmail.com/settings/change-email" method="POST">
  <input type="hidden" name="email" value="hacker@gmail.com">
</form>
<script>
  document.forms[0].submit();  // User's email changed without consent
</script>
```

### **Example 3: Social Media Actions**
```html
<!-- Post on user's behalf -->
<form action="https://twitter.com/tweet" method="POST">
  <input type="hidden" name="status" 
         value="I love this malicious site! Visit evil.com">
</form>
<script>
  setTimeout(() => document.forms[0].submit(), 3000);
</script>
```

## 4. Difference Between CSRF and XSS

### **Comparison Table:**
| **Aspect** | **CSRF** | **XSS** |
|------------|----------|---------|
| **Attack Vector** | Malicious website | Vulnerable website |
| **Execution** | Browser sends requests | Browser executes scripts |
| **Target** | Actions on other sites | Users of vulnerable site |
| **Payload Location** | External site | Vulnerable site itself |
| **Cookie Access** | Automatically sent | Stolen via JavaScript |
| **Defense** | CSRF tokens, SameSite | Input sanitization, CSP |

### **Key Insight:**
- **CSRF**: "Trusting the browser too much"
- **XSS**: "Trusting user input too much"

## 5. Which HTTP Methods Are Affected and Why

### **Vulnerable Methods:**
```
GET  - Most vulnerable (img tags, links)
POST - Very vulnerable (forms, fetch)
PUT  - Vulnerable (REST APIs)
DELETE - Vulnerable (REST APIs)

HEAD, OPTIONS, TRACE - Usually not dangerous
```

### **Why GET is Especially Dangerous:**
```html
<!-- GET request CSRF - No user interaction needed -->
<img src="https://bank.com/logout">
<!-- User logged out without clicking anything -->

<a href="https://bank.com/delete-account">Win a prize!</a>
<!-- User clicks thinking it's a legitimate link -->
```

### **Modern REST API Considerations:**
```javascript
// Even JSON APIs are vulnerable
fetch('https://api.bank.com/transfer', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    // NO custom headers = Simple request = No preflight
  },
  body: JSON.stringify({ to: 'hacker', amount: 1000 }),
  // Cookies still sent automatically!
  credentials: 'include'  // Or 'same-origin' by default for same origin
});
```

## 6. Impact of CSRF on User Accounts and Systems

### **Potential Damages:**
```
┌──────────────────────┬─────────────────────────────────────┐
│ Impact Area          │ Examples                            │
├──────────────────────┼─────────────────────────────────────┤
│ Financial Loss       │ Bank transfers, purchases           │
│ Data Breach          │ Email change, password reset        │
│ Reputation Damage    │ Social media posts, comments        │
│ Account Takeover     │ Email/phone number change           │
│ Service Disruption   │ Logout, account deletion            │
│ Privacy Violation    │ Settings changes, data exposure     │
└──────────────────────┴─────────────────────────────────────┘
```

### **Business Impact Scale:**
```javascript
const csrfImpact = {
  low: ['Logout', 'Theme change'],
  medium: ['Comment posting', 'Profile update'],
  high: ['Email change', 'Address update'],
  critical: ['Money transfer', 'Password change', 'Account deletion']
};
```

## 7. Role of Frontend vs Backend in Preventing CSRF

### **Frontend Responsibilities:**
1. Include CSRF tokens in forms/requests
2. Implement proper CORS policies
3. Use secure cookie flags
4. Handle token storage and transmission

### **Backend Responsibilities:**
1. Generate and validate CSRF tokens
2. Implement SameSite cookie attributes
3. Verify Origin/Referer headers
4. Maintain token sessions

### **Collaboration Required:**
```javascript
// Frontend: Get token from backend
fetch('/api/csrf-token')
  .then(res => res.json())
  .then(data => {
    // Store token for future requests
    localStorage.setItem('csrf-token', data.token);
  });

// Backend: Generate and validate
app.get('/api/csrf-token', (req, res) => {
  const token = generateCSRFToken(req.session);
  res.json({ token });
});

app.post('/api/transfer', (req, res) => {
  if (!validateCSRFToken(req.body.csrf_token, req.session)) {
    return res.status(403).send('CSRF validation failed');
  }
  // Process request
});
```

## 8. CSRF Protection Techniques

### **Technique 1: CSRF Tokens (Most Common)**
```javascript
// Server generates a unique token per session
const generateCSRFToken = (session) => {
  return crypto.randomBytes(32).toString('hex');
  // Store in session: session.csrfToken = token
};

// Frontend includes token in every state-changing request
const formData = new FormData();
formData.append('amount', 1000);
formData.append('to', 'friend@email.com');
formData.append('csrf_token', csrfToken);  // From meta tag or API

// Server validates token matches session
const validateCSRFToken = (req) => {
  return req.body.csrf_token === req.session.csrfToken;
};
```

### **Technique 2: SameSite Cookies**
```http
Set-Cookie: session=abc123; SameSite=Strict; Secure; HttpOnly
```

**SameSite Options:**
- **Strict**: Never sent with cross-site requests
- **Lax**: Sent with top-level navigation GET requests
- **None**: Always sent (requires Secure flag)

```javascript
// Cookie configuration
res.cookie('session', sessionId, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',  // or 'lax' for better UX
  maxAge: 24 * 60 * 60 * 1000
});
```

### **Technique 3: Origin/Referer Validation**
```javascript
app.use((req, res, next) => {
  const origin = req.headers.origin;
  const referer = req.headers.referer;
  
  // Check if request comes from same origin
  if (origin && !origin.startsWith('https://yourdomain.com')) {
    return res.status(403).send('Cross-origin request denied');
  }
  
  // OR check Referer header
  if (referer && !referer.startsWith('https://yourdomain.com')) {
    return res.status(403).send('Invalid referer');
  }
  
  next();
});
```

### **Technique 4: Double-Submit Cookies**
```javascript
// 1. Server sets a random cookie
Set-Cookie: csrf-token=random123; SameSite=Lax

// 2. Frontend reads cookie and sends in request header
fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': getCookie('csrf-token')  // Read from cookies
  }
});

// 3. Server compares cookie value with header
if (req.cookies['csrf-token'] !== req.headers['x-csrf-token']) {
  return res.status(403).send('CSRF validation failed');
}
```

### **Technique 5: Custom Headers (for API requests)**
```javascript
// Relies on CORS policy - browser won't allow custom headers cross-origin
// without server permission

// Frontend adds custom header
fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-Requested-With': 'XMLHttpRequest',  // Custom header
    'Content-Type': 'application/json'
  }
});

// Backend checks for custom header
app.post('/api/transfer', (req, res) => {
  if (!req.headers['x-requested-with']) {
    return res.status(403).send('Missing custom header');
  }
  // Process request
});
```

## 9. How Modern Frameworks Handle CSRF

### **React (with Axios):**
```javascript
// Setup CSRF token interceptor
import axios from 'axios';

// Read token from meta tag (if server-rendered)
const csrfToken = document.querySelector('meta[name="csrf-token"]')
  ?.getAttribute('content');

// OR get from cookie
const getCSRFToken = () => {
  return document.cookie
    .split('; ')
    .find(row => row.startsWith('XSRF-TOKEN='))
    ?.split('=')[1];
};

// Configure axios
axios.defaults.xsrfCookieName = 'XSRF-TOKEN';
axios.defaults.xsrfHeaderName = 'X-XSRF-TOKEN';
axios.defaults.withCredentials = true;

// All requests automatically include CSRF token
axios.post('/api/transfer', { amount: 100, to: 'friend' });
```

### **Angular:**
```typescript
// HttpClient automatically handles CSRF
import { HttpClient, HttpClientXsrfModule } from '@angular/common/http';

@NgModule({
  imports: [
    HttpClientXsrfModule.withOptions({
      cookieName: 'XSRF-TOKEN',
      headerName: 'X-XSRF-TOKEN'
    })
  ]
})
export class AppModule {}

// Service using HttpClient
@Injectable()
export class TransferService {
  constructor(private http: HttpClient) {}
  
  transfer(amount: number, to: string) {
    return this.http.post('/api/transfer', { amount, to });
    // Automatically includes CSRF token
  }
}
```

### **Vue.js:**
```javascript
// Using axios with Vue
import axios from 'axios';
import Vue from 'vue';

// Configure axios
axios.defaults.xsrfCookieName = 'csrftoken';
axios.defaults.xsrfHeaderName = 'X-CSRFToken';

// Use in Vue component
export default {
  methods: {
    async transferMoney() {
      try {
        const response = await axios.post('/api/transfer', {
          amount: this.amount,
          to: this.recipient
        });
        // CSRF token automatically included
      } catch (error) {
        console.error('Transfer failed:', error);
      }
    }
  }
}
```

## 10. How CSRF Influences Frontend System Design Decisions

### **Architectural Considerations:**

**Decision 1: SPA vs Traditional Multi-Page**
```javascript
// Traditional multi-page: Tokens in forms
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
  <!-- Other fields -->
</form>

// SPA: Tokens in API requests
fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': localStorage.getItem('csrf_token')
  }
});
```

**Decision 2: Stateless vs Stateful Authentication**
```javascript
// Stateless (JWT): Need CSRF protection for cookie storage
// If JWT in cookie -> vulnerable to CSRF
// If JWT in localStorage -> not vulnerable to CSRF, but vulnerable to XSS

// Stateful (Session cookies): Always need CSRF protection
```

**Decision 3: API Design**
```javascript
// Design APIs with CSRF in mind

// GOOD: State-changing endpoints require CSRF token
POST /api/transfer
PUT /api/user/profile
DELETE /api/comment/:id

// SAFE: Read-only endpoints don't need CSRF
GET /api/user/profile
GET /api/transactions
```

### **Frontend System Design Patterns:**

**Pattern 1: Request Interceptor Pattern**
```javascript
// Centralized request handling with CSRF
class API {
  constructor() {
    this.csrfToken = null;
  }
  
  async init() {
    this.csrfToken = await this.fetchCSRFToken();
  }
  
  async request(endpoint, options = {}) {
    const headers = {
      'X-CSRF-Token': this.csrfToken,
      ...options.headers
    };
    
    return fetch(endpoint, { ...options, headers });
  }
  
  async fetchCSRFToken() {
    const response = await fetch('/api/csrf-token');
    const data = await response.json();
    return data.token;
  }
}
```

**Pattern 2: Token Refresh Strategy**
```javascript
// Handle token expiration
const withCSRF = async (requestFn) => {
  try {
    return await requestFn();
  } catch (error) {
    if (error.status === 403 && error.message.includes('CSRF')) {
      // Token expired, refresh it
      await refreshCSRFToken();
      // Retry request
      return await requestFn();
    }
    throw error;
  }
};
```

## 11. Common Mistakes Developers Make

### **Mistake 1: Protecting Only POST Requests**
```javascript
// WRONG: GET requests can also change state
app.get('/delete-account', deleteAccount);  // Vulnerable!

// RIGHT: Protect ALL state-changing endpoints
app.delete('/account', csrfProtection, deleteAccount);
```

### **Mistake 2: Token Not Bound to Session**
```javascript
// WRONG: Same token for all users
const STATIC_TOKEN = 'secret123';  // ❌

// RIGHT: Unique token per session
const token = crypto.randomBytes(32).toString('hex');
req.session.csrfToken = token;  // ✅
```

### **Mistake 3: Token in URL**
```javascript
// WRONG: Token in URL can leak in logs/referers
https://bank.com/transfer?to=hacker&csrf_token=abc123

// RIGHT: Token in header or body
headers: { 'X-CSRF-Token': 'abc123' }
```

### **Mistake 4: Not Using SameSite Cookies with Tokens**
```javascript
// Defense in depth: Use both!
res.cookie('session', sessionId, {
  sameSite: 'lax',  // First layer
  httpOnly: true
});

// Plus CSRF token validation  // Second layer
```

### **Mistake 5: Assuming CORS Protects Against CSRF**
```javascript
// CORS doesn't prevent CSRF!
// CORS controls READING responses, not SENDING requests
// Malicious site can still send request (without reading response)
```

## 12. How to Explain CSRF in Interviews

### **Clear, Structured Explanation Template:**

```
"CSRF is an attack where a malicious site tricks a user's browser 
into making unauthorized requests to a legitimate site where the 
user is already logged in.

Let me explain with a simple analogy:

Imagine your browser is a postal service. When you log into a bank 
website, the bank gives you a special stamp (session cookie). 
Normally, when you send mail to the bank, you use this stamp.

CSRF is like a malicious person giving you a pre-stamped envelope 
addressed to the bank with instructions to transfer money. You 
unknowingly mail it, and since it has your valid stamp, the bank 
processes it.

In technical terms:
1. User logs into Bank.com → gets session cookie
2. User visits Evil.com → contains hidden form to Bank.com
3. Browser submits form → automatically includes Bank.com cookies
4. Bank.com sees valid session → processes malicious request

The key insight is that browsers automatically include cookies 
for the target domain, regardless of where the request originates.

To prevent this, we use:
1. CSRF tokens: Unique per session, validated server-side
2. SameSite cookies: Prevent cross-site cookie sending
3. Origin validation: Check request source

For frontend design, this means:
- Always include CSRF tokens in state-changing requests
- Configure CORS properly
- Use framework-provided CSRF protection
- Implement defense in depth with multiple layers"
```

### **Whiteboard Diagram for Interviews:**
```
┌─────────────────────────────────────────────────────────────┐
│                    CSRF Attack Flow                         │
├─────────────────────────────────────────────────────────────┤
│   Step 1: User logs into legitimate site                    │
│   [User] ──────[Login]─────> [Legitimate Site]              │
│                <──[Session Cookie]───                       │
│                                                            │
│   Step 2: User visits malicious site                       │
│   [User] ──────[Visit]─────> [Malicious Site]              │
│                                                            │
│   Step 3: Malicious site triggers request                  │
│   [Malicious Site] ──[Hidden Form]──> [User's Browser]     │
│                                                            │
│   Step 4: Browser sends request with cookies               │
│   [User's Browser] ─────[Request + Cookies]────>           │
│                            [Legitimate Site]               │
│                                                            │
│   Step 5: Legitimate site processes request                │
│   [Legitimate Site] ──[Unauthorized Action]──> [Database]  │
└─────────────────────────────────────────────────────────────┘
```

### **Common Interview Questions & Responses:**

**Q: "Explain CSRF like I'm 5"**
```
"Imagine you have a special key (cookie) to your piggy bank (website).
A tricky friend (malicious site) gives you a note that says 
'Take $10 from your piggy bank and give it to me.' 
You put the note in the piggy bank's slot. 
The piggy bank sees your special key is attached, 
so it follows the note's instructions, even though 
you didn't mean to give away your money.

CSRF protection is like the piggy bank saying 
'Only follow instructions written on special paper (CSRF tokens) 
that I gave you, not on any random note.'"
```

**Q: "Why doesn't Same-Origin Policy prevent CSRF?"**
```
"SOP prevents websites from *reading* responses from other origins,
but it doesn't prevent *sending* requests to other origins.

Think of it like sending mail: 
SOP says 'You can't read someone else's mail' 
but it doesn't say 'You can't send mail to someone.'

CSRF exploits this by sending requests (sending mail) 
without needing to read the response (read the reply)."
```

**Q: "How do you choose between CSRF tokens and SameSite cookies?"**
```
"I use both for defense in depth:

1. **SameSite cookies** (first layer):
   - Simple to implement
   - Blocks most basic CSRF attacks
   - But not supported in old browsers

2. **CSRF tokens** (second layer):
   - More robust protection
   - Works in all browsers
   - Requires more implementation effort

In practice: Set `SameSite=Strict` or `Lax` on session cookies,
AND implement CSRF tokens for critical operations.

For read-only APIs or public endpoints, SameSite might be sufficient.
For state-changing operations, always use tokens."
```

**Q: "How does CSRF affect microservices architecture?"**
```
"In microservices, CSRF protection becomes more complex:

1. **API Gateway Pattern**: Handle CSRF at the gateway level
   - Single point of validation
   - Consistent across services

2. **Shared Auth Service**: Centralized token validation
   - All services validate against same auth service
   - Consistent session management

3. **JWT with Claims**: Include CSRF token in JWT
   - Each service can independently validate
   - Stateless validation

Key challenge: Ensuring consistent CSRF protection 
across all services that accept browser requests."
```

### **Key Takeaways for Interviews:**
1. **CSRF exploits automatic cookie sending** - browsers include cookies for target domain
2. **SOP doesn't block CSRF** - only blocks reading responses, not sending requests
3. **Defense in depth** - Use multiple layers (SameSite + tokens + validation)
4. **Protect all state-changing methods** - Not just POST
5. **Framework awareness** - Know how your framework handles CSRF
6. **Real-world impact** - Emphasize business consequences (financial loss, data breach)

This comprehensive understanding demonstrates both technical depth and practical implementation knowledge for frontend system design interviews.