Refer: https://developer.mozilla.org/en-US/docs/Web/Security/Defenses/Subresource_Integrity


Subresource Integrity (SRI):

1. What SRI is and its Primary Purpose

- Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources (typically JavaScript files or CSS stylesheets) fetched from a third-party server or Content Delivery Network (CDN) have not been tampered with.

- The primary purpose is cryptographic verification. 
- By providing a base64-encoded cryptographic hash of the resource in your HTML, you instruct the browser to calculate the hash of the downloaded file and compare it against your provided value. 
- If the hashes do not match exactly, the browser refuses to execute the script or apply the stylesheet.

---

2. Security Risks it Mitigates

SRI is the primary defense against Third-Party Supply Chain Attacks.

* CDN Compromise: If an attacker gains access to a popular CDN (like cdnjs or a private S3 bucket) and modifies a common library (e.g., lodash.js) to include a credential-stealing script, every website using that CDN would normally execute the malicious code. SRI prevents this by detecting the change in the file's fingerprint.

* Magecart Attacks: These attacks involve injecting malicious code into third-party scripts (like analytics or payment trackers) to scrape credit card data. SRI ensures that even if the vendor's server is breached, the modified script is blocked on your site.

* Man-in-the-Middle (MITM) Alterations: While HTTPS encrypts the connection, a compromised proxy or a malicious network actor could theoretically attempt to inject code into a stream. SRI provides an end-to-end integrity check that persists regardless of the transport layer's security.

Real-World Example: In 2018, the British Airways website was compromised via a third-party script (Modernizr), leading to the theft of data from 380,000 customers. SRI would have rendered this attack ineffective by blocking the modified script.

---

3. How it Works Technically

SRI uses the integrity attribute on <script> and <link> tags. The process follows these steps:

1. Selection of Algorithm: Developers choose a hash function, typically SHA-256, SHA-384, or SHA-512.
2. Browser Fetch: The browser initiates the request for the resource.
3. CORS Requirement: For SRI to work on cross-origin requests, the resource must be served with appropriate CORS headers (Access-Control-Allow-Origin). The HTML tag must also include crossorigin="anonymous".
4. Verification: The browser downloads the file, computes the hash locally, and compares it.
5. Execution/Blocking:
* Match: The script executes.
* Mismatch: The browser blocks the script and throws a network error in the console.



---

4. Best Practices for Implementation in Large-Scale Frontend Systems

Recommended Implementation (Express-server)

In an Express environment, you rarely want to manually calculate hashes. Instead, you should automate the injection of hashes into your templates (EJS, Pug, etc.) during the build process.


// Express middleware example (Conceptual)
// In production, these hashes are usually generated by Webpack/Vite
const assets = {
  'main.js': {
    url: 'https://cdn.example.com/main.v123.js',
    sri: 'sha384-Li9vy3DqF8tnMctjsSBGR1f1StQ3bmCLP16B86pXk0v6vWO5VP48v8495FM9XfOw'
  }
};

app.get('/', (req, res) => {
  res.render('index', { assets });
});



How Top Companies Approach It

* Build-Time Generation: Modern pipelines (Vite, Webpack, Esbuild) use plugins to automatically generate hashes for all bundled assets. This ensures that every deployment has unique, valid SRI hashes.
* SHA-384 Standard: While SHA-256 is secure, most "Big Tech" security policies mandate SHA-384 as the sweet spot between hash length and collision resistance.
* Third-Party Auditing: For essential third-party scripts (Google Analytics, Stripe), companies monitor the vendor's provided SRI hashes. If the vendor doesn't provide them, security teams often host a "frozen" version of the script on their own internal CDN to maintain control.

Common Pitfalls

* Forgetting CORS: If you add integrity but forget crossorigin="anonymous", the browser will block the script entirely for security reasons.
* Dynamic Scripts: SRI is difficult to apply to scripts that change their content based on the user or the time (e.g., some personalized ad scripts). These are high-risk and should be minimized.

---

5. Frontend System Design Considerations at Scale

Integration Points: Automation is Mandatory

In a system with thousands of files, manual SRI management is impossible.

* Bundler Integration: Use webpack-subresource-integrity or Vite's built-in support.
* CDN Strategy: Use Immutable URLs. Never use SRI on a "latest" tag (e.g., jquery/latest/jquery.js). If the vendor updates the "latest" file, your SRI hash will break, and your site will go down. Always point to specific versions (e.g., jquery/3.6.0/jquery.js).

Impact on Performance and Workflow

* Performance: There is a negligible CPU overhead as the browser calculates the hash. However, this happens during the download/parsing phase and rarely impacts the critical rendering path.
* Error Recovery: At scale, you must plan for SRI Failure. A CDN could be under a localized attack or have a corrupted cache.
* Fallback Pattern: Implement a small inline script that detects if a global variable (e.g., window.jQuery) is missing after the CDN load and falls back to a local version of the script.



Micro-Frontend (MFE) Considerations

In an MFE architecture, the "Shell" application often loads remote fragments. Each fragment's metadata should include its own SRI hash, which the Shell verifies before mounting the micro-app.

---

6. Example Configuration

Standard CDN Script (Strict/Ideal)

<script 
  src="https://code.jquery.com/jquery-3.7.1.min.js" 
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" 
  crossorigin="anonymous">
</script>



Balanced/Resilient Approach (With Fallback)

<script 
  src="https://cdn.example.com/app.js" 
  integrity="sha384-..." 
  crossorigin="anonymous">
</script>
<script>
  if (!window.AppLoaded) {
    document.write('<script src="/js/fallback-app.js"><\/script>');
  }
</script>



---

7. Current Status and Deprecations (as of 2026)

* Status: Standardized and Essential. SRI is a non-negotiable requirement for passing modern security audits (PCI-DSS, SOC2).
* 2026 Context: We are seeing the rise of Signed Exchanges (SXG) and Web Bundles, which provide similar integrity guarantees at the binary level. However, SRI remains the universal standard for individual resource verification.
* CSP Interaction: Modern Content-Security-Policy (CSP) directives like require-sri-for script style; can now enforce that *all* resources on a page must have an SRI hash, or they will be blocked by default.

---

8. crossorigin="anonymous" 

crossorigin="anonymous" is needed with Subresource Integrity (SRI) because the browser must fetch the resource using CORS-enabled requests to verify its integrity hash. When a resource (like a script or stylesheet) is loaded from a different origin, the browser will only perform the SRI check if the response is accessible under CORS rules. Setting crossorigin="anonymous" tells the browser to request the resource without credentials (cookies, auth headers) but still require the server to send appropriate CORS headers. Without it, the browser may treat the response as opaque and skip or fail the integrity check, causing the resource to be blocked.
