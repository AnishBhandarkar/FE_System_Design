Below content is from here:
https://chat.deepseek.com/share/6brnjjmonlqwbu4g6m



# Server-Side Request Forgery (SSRF) - Complete Front-End System Design Guide

## 1. What is SSRF? - The Core Concept

**Definition**: SSRF is a web security vulnerability that allows an attacker to make the **server** perform HTTP requests to unintended locations, typically internal systems or external third-party services.

**High-Level Overview**:
```
Attacker → Frontend → Backend → INTERNAL/EXTERNAL TARGET
    ↓           ↓          ↓            ↑
Malicious    Sends     Trusts FE    Server makes
payload      request   request      request on
                        (no auth     attacker's
                        checks)      behalf
```

**Key Insight**: The server becomes the attacker's **proxy**, bypassing network security controls like firewalls because internal networks often trust server traffic.

## 2. Why SSRF is Dangerous in Modern Architectures

**Modern systems amplify SSRF risk** because:
- **Microservices**: Many internal APIs (payment, user, inventory) accessible via HTTP
- **Cloud Metadata**: Services like AWS IMDS (169.254.169.254) expose credentials
- **Kubernetes**: Internal APIs at fixed addresses (10.0.0.1, 192.168.0.1)
- **Serverless**: Functions often have broad IAM roles
- **Container Orchestration**: Docker socket, internal registries

**Impact Escalation**:
1. **Information Disclosure** → Internal service enumeration
2. **Internal Service Attack** → Database access, admin panels
3. **Cloud Compromise** → Instance metadata → IAM credentials
4. **Remote Code Execution** → Through internal services

## 3. How SSRF Attacks Work - Technical Flow

### Front-End Scenario (Image Preview Feature)

```javascript
// FRONTEND - Image preview component
async function fetchImagePreview(url) {
  // User provides URL, FE sends to backend
  const response = await fetch('/api/preview-image', {
    method: 'POST',
    body: JSON.stringify({ imageUrl: url }),
    headers: { 'Content-Type': 'application/json' }
  });
  return response.json();
}

// User can input: http://attacker.com/normal.jpg
// OR malicious: http://169.254.169.254/latest/meta-data/
```

### Backend Processing (Vulnerable)

```javascript
// BACKEND - Express.js (VULNERABLE VERSION)
app.post('/api/preview-image', async (req, res) => {
  const { imageUrl } = req.body;
  
  // SSRF VULNERABILITY: No validation of user-provided URL
  const response = await fetch(imageUrl); // Server makes request
  
  // Process image...
  const imageBuffer = await response.buffer();
  
  res.json({ preview: imageBuffer.toString('base64') });
});
```

**Attack Flow**:
```
1. Attacker submits: http://169.254.169.254/latest/meta-data/
2. Frontend sends to: POST /api/preview-image
3. Backend fetches: AWS Metadata Service
4. Returns: IAM credentials, instance data
5. Attacker now controls cloud resources
```

## 4. Basic SSRF vs Blind SSRF

**Basic SSRF**: Response returned to attacker
```ascii
Attacker → Server → Target
    ↑                    ↓
Response ←───────────────┘
```

**Blind SSRF**: No direct response, but server performs action
```ascii
Attacker → Server → Target (internal service)
    ↑                    ↓
Partial feedback ←───────┘ (delayed, side-channel)
```
*Example*: Trigger webhook to internal CI/CD → deploy malicious code

## 5. Internal vs External SSRF Targets

**Internal Targets** (Most Dangerous):
- `127.0.0.1`, `localhost`, `::1` (loopback)
- `169.254.169.254` (AWS, Azure, GCP metadata)
- `192.168.x.x`, `10.x.x.x`, `172.16.x.x` (private IPs)
- Internal domain names: `internal.api`, `database.local`

**External Targets** (Still Risky):
- Third-party services with internal context
- Attack-controlled servers (data exfiltration)
- Server-side port scanning

## 6. Common SSRF Entry Points

### Front-End Features That Enable SSRF:

| Feature | Risk | Example |
|---------|------|---------|
| **URL Previews** | High | Social media link previews |
| **File Import/Export** | High | Import from URL, export to webhook |
| **Webhook Configuration** | Critical | User-defined callback URLs |
| **Image Processing** | Medium | Avatar URLs, image resizing |
| **Document Conversion** | High | PDF generation from URLs |
| **SSO/OAuth Callbacks** | Medium | Redirect URI validation |
| **API Gateway Proxies** | Critical | `/proxy?url=` endpoints |

### Real Production Examples:

1. **E-commerce**: "Fetch product details from supplier URL"
2. **Social Media**: "Generate preview of shared link"
3. **CMS**: "Import content from external source"
4. **DevOps Tools**: "Test webhook endpoint"
5. **Monitoring**: "Check if URL is reachable"

## 7. Cloud & Infrastructure Risks

**AWS Metadata Service** (IMDSv1):
```
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/user-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE-NAME
```

**Kubernetes API**:
```
https://kubernetes.default.svc
http://10.0.0.1 (API server)
http://10.96.0.1 (DNS)
```

**Docker Network**:
```
http://host.docker.internal
http://gateway.docker.internal
http://172.17.0.1 (Docker bridge)
```

## 8. Front-End Relevance and Responsibilities

### How FE Engineers Contribute to SSRF:

**Dangerous Patterns:**
```javascript
// BAD: FE sends raw URLs without context
const response = await fetch('/api/fetch-external', {
  body: JSON.stringify({ url: userInput })
});

// BETTER: FE validates/sanitizes before sending
function validateAndFetch(url) {
  const parsed = new URL(url);
  if (!isAllowedDomain(parsed.hostname)) {
    throw new Error('Domain not allowed');
  }
  // Send with additional context
  return fetch('/api/fetch-external', {
    body: JSON.stringify({
      url,
      contentType: 'image', // Context helps backend validate
      source: 'user-upload'
    })
  });
}
```

**FE Prevention Responsibilities:**
1. **Input Validation**: Basic URL format checking
2. **User Feedback**: Clear warnings about supported URLs
3. **UI/UX Design**: Don't encourage arbitrary URL inputs
4. **Context Provision**: Send metadata about WHY URL is needed

## 9. Prevention and Mitigation Strategies

### Multi-Layered Defense:

**Layer 1: Input Validation (FE + BE)**
```javascript
// URL Validation Function
function validateSSRFUrl(inputUrl, allowedDomains) {
  const url = new URL(inputUrl);
  
  // 1. Block dangerous protocols
  if (!['http:', 'https:'].includes(url.protocol)) {
    throw new Error('Invalid protocol');
  }
  
  // 2. Resolve DNS before using
  const resolvedIp = dnsResolveSync(url.hostname);
  
  // 3. Block internal IPs
  if (isInternalIP(resolvedIp)) {
    throw new Error('Internal IP not allowed');
  }
  
  // 4. Domain allowlist (not just blocklist!)
  if (!allowedDomains.includes(url.hostname)) {
    throw new Error('Domain not allowed');
  }
  
  // 5. Path restrictions
  if (url.pathname.includes('..') || url.pathname.includes('//')) {
    throw new Error('Invalid path');
  }
  
  return url;
}
```

**Layer 2: Network Controls**
```yaml
# Infrastructure as Code example (Terraform-like)
network_policy:
  egress_filtering:
    deny:
      - 127.0.0.0/8
      - 10.0.0.0/8
      - 169.254.169.254/32
      - 192.168.0.0/16
  proxy_configuration:
    use_upstream_proxy: true  # All outbound via proxy
    require_domain_allowlist: true
```

**Layer 3: Secure Service Design**
```javascript
// Secure Backend Service Pattern
class SecureURLFetcher {
  constructor() {
    this.allowedDomains = new Set(ALLOWED_DOMAINS);
    this.httpClient = axios.create({
      timeout: 5000,
      maxRedirects: 2,
      // Use a dedicated network interface
      localAddress: '10.1.2.3',
      // Set Host header to prevent virtual host confusion
      headers: { 'Host': 'safe-fetcher.internal' }
    });
  }
  
  async fetchSafely(url, expectedContentType) {
    // 1. Parse and validate
    const validated = await this.validateUrl(url);
    
    // 2. Use outbound proxy with filtering
    const response = await this.httpClient.get(validated.href, {
      proxy: {
        host: 'secure-proxy.internal',
        port: 3128,
        protocol: 'http'
      }
    });
    
    // 3. Validate response
    if (!this.isExpectedContent(response, expectedContentType)) {
      throw new Error('Unexpected content type');
    }
    
    return response.data;
  }
}
```

## 10. SSRF in System Design

### Architecture Patterns:

**Pattern A: Dedicated Proxy Service**
```
┌─────────┐    ┌─────────────┐    ┌──────────────┐
│   App   │───▶│ SSRF Proxy  │───▶│  External    │
│ Server  │    │ (Validates, │    │   Service    │
│         │◀───│   Logs)     │◀───│              │
└─────────┘    └─────────────┘    └──────────────┘
```

**Pattern B: Zero-Trust Outbound**
```yaml
design:
  approach: "Assume breach, verify everything"
  components:
    - identity_aware_proxy: "All outbound requests authenticated"
    - service_mesh: "mTLS for internal communication"
    - egress_gateway: "Centralized outbound control"
```

**Trade-offs Consideration Table**:

| Approach | Security | Complexity | Flexibility |
|----------|----------|------------|-------------|
| Allowlist Only | High | Medium | Low |
| Proxy + Filter | High | High | Medium |
| DNS Resolve + Block | Medium | Low | High |
| No Protection | None | None | Maximum |

## 11. Detection and Monitoring

**Logging Strategy**:
```javascript
// Comprehensive SSRF logging
function logSSRFAction(requestDetails) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    userId: requestDetails.userId,
    sourceIp: requestDetails.sourceIp,
    requestedUrl: requestDetails.url,
    resolvedIp: requestDetails.resolvedIp,
    requestHeaders: requestDetails.headers,
    responseStatus: requestDetails.responseStatus,
    responseSize: requestDetails.responseSize,
    // Critical for investigation
    traceId: requestDetails.traceId,
    requestStack: new Error().stack // Capture call stack
  };
  
  // Send to security monitoring
  securityLogger.log('ssrf_attempt', logEntry);
  
  // Alert on suspicious patterns
  if (isSuspicious(requestDetails)) {
    alertSecurityTeam(logEntry);
  }
}
```

**Anomaly Detection Rules**:
1. **Volume**: >5 unique internal IP requests/user/hour
2. **Pattern**: Sequential port scanning (ports 1-100)
3. **Target**: Known metadata endpoints
4. **Timing**: Requests to `localhost` from production

## 12. Common Misconceptions

### **Myth 1**: "SSRF is only a backend issue"
**Reality**: FE design influences SSRF risk. Poor UX (allowing arbitrary URLs) increases attack surface.

### **Myth 2**: "Blocking localhost is enough"
**Reality**: Attackers use:
- IPv6: `[::]`, `[::1]`
- Decimal encoding: `2130706433` = `127.0.0.1`
- Domain redirection: `attacker.com → localhost`
- DNS rebinding attacks

### **Myth 3**: "Firewall solves SSRF"
**Reality**: Firewalls help but:
- Apps need outbound internet access
- Internal services need communication
- Zero-day internal services might be exposed

### **Myth 4**: "URL parsers prevent SSRF"
**Reality**: URL parsing inconsistencies:
```javascript
// Different parsers, different results
new URL('http://example.com@127.0.0.1') // Some see example.com
url.parse('http://example.com@127.0.0.1') // Others see 127.0.0.1
```

## 13. SSRF in Interviews - How to Explain

### Clear 2-Minute Explanation:
"SSRF is when an attacker tricks a server into making requests to internal systems it shouldn't access. Think of it as the server becoming a malicious proxy. In modern cloud environments, this is critical because servers often have privileged access to metadata services, internal APIs, and cloud management endpoints that external users should never reach."

### Common Interview Questions:

**Q1**: "How would you design a URL preview feature safely?"
**A**: "I'd implement a three-layer defense: 1) Frontend validates URL format and provides context, 2) Backend uses an allowlist of permitted domains with DNS resolution to check for internal IPs, 3) All outbound requests go through a dedicated proxy service with logging and rate limiting."

**Q2**: "What's the difference between SSRF and CSRF?"
**A**: "CSRF tricks a user's browser into making unwanted requests with the user's credentials. SSRF tricks a server into making requests on the attacker's behalf. CSRF targets user sessions; SSRF targets server privileges and internal network access."

**Q3**: "How does microservices architecture affect SSRF risk?"
**A**: "It increases risk exponentially. Each service might have different security postures, internal APIs are often HTTP-based, and service discovery creates predictable internal endpoints. However, it also allows for better isolation - we can design a dedicated, heavily secured service for all external fetching."

### Real-World Examples (Non-Exploit):

1. **Shopify (2019)**: Partner could request internal endpoints through GraphQL
2. **Microsoft Azure (2021)**: Auto-generated documentation fetched internal URLs
3. **AWS EC2**: Default IMDSv1 vulnerable to SSRF until IMDSv2 enforced

## 14. Interview Summary Cheat Sheet

**Key Points to Remember**:
1. SSRF turns your server into an attacker-controlled proxy
2. Modern cloud makes SSRF critical (metadata, internal APIs)
3. Defense requires multiple layers (validation, network controls, monitoring)
4. FE engineers contribute through UX design and input validation
5. Zero-trust architecture minimizes SSRF impact

**When Discussing in Interviews**:
- Emphasize **defense in depth**
- Mention **real cloud services** (AWS metadata, K8s API)
- Discuss **trade-offs** (security vs functionality)
- Propose **monitoring and detection** strategies
- Connect to **broader security principles** (least privilege, zero trust)

**Final Architecture Diagram**:
```
┌─────────────────────────────────────────────────┐
│              USER SUPPLIED URL                  │
└───────────────────────┬─────────────────────────┘
                        │
        ┌───────────────▼────────────────┐
        │   FRONTEND: Basic Validation   │
        │   - URL format                 │
        │   - User feedback              │
        │   - Request context            │
        └───────────────┬────────────────┘
                        │
        ┌───────────────▼────────────────┐
        │    BACKEND: Deep Validation    │
        │  1. Parse with safe library    │
        │  2. DNS resolve + IP check     │
        │  3. Domain allowlist           │
        │  4. Content-type expectation   │
        └───────────────┬────────────────┘
                        │
        ┌───────────────▼────────────────┐
        │   NETWORK: Egress Controls     │
        │   - Outbound proxy             │
        │   - Firewall rules             │
        │   - Dedicated network path     │
        └───────────────┬────────────────┘
                        │
        ┌───────────────▼────────────────┐
        │        MONITORING & LOGS       │
        │   - All outbound requests      │
        │   - Anomaly detection          │
        │   - Security alerts            │
        └────────────────────────────────┘
```

Remember: SSRF prevention is about **assuming URLs are malicious until proven safe**, not the opposite. In system design interviews, demonstrate this security-first mindset while balancing business needs.