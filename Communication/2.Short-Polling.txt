What is Short Polling?

Short polling is a technique where the frontend repeatedly asks the server for updates at fixed time intervals.

ðŸ§  Think of it like:

> â€œAny update now?â€ â†’ No
> (wait 5 seconds)
> â€œAny update now?â€ â†’ Yes

Each request:

* Is a normal HTTP request
* Gets a quick response
* Then closes

---

When is Short Polling Needed?

Use short polling when:

> Best-fit scenarios
* You need nearâ€“real-time updates, but not instant
* Updates are infrequent or unpredictable
* Backend does NOT support:
  * WebSockets
  * Server-Sent Events (SSE)
* Simpler systems or legacy APIs
* Statelessness is required - Your backend is purely serverless (like AWS Lambda) and cannot easily maintain persistent connections.


> Common examples
* Notification count (email, alerts)
* Order status updates
* Job/task progress
* Dashboard refreshes

---

> How Short Polling Works (Step-by-step)

1. Frontend sends a request (e.g., /api/status)
2. Server responds immediately (with or without new data)
3. Frontend waits for a fixed time
4. Frontend sends the request again
5. Repeat

---

> Pros of Short Polling

- Simple to implement
- Works with standard HTTP
- Supported by all browsers & servers
- Easy to debug
- No persistent connections
- If a request fails, the next one will just try again. No complex "reconnection logic" needed.

---

> Cons of Short Polling

- Unnecessary requests when no data changes
- Higher server load
- Not real-time (delay depends on interval)
- Wastes bandwidth
- Poor scalability for many users

Rule of thumb:
> Short polling trades simplicity for efficiency

---

> How to Implement Short Polling in JavaScript

Basic Example (using setInterval)

const POLL_INTERVAL = 5000; // 5 seconds

function fetchUpdates() {
  fetch("/api/notifications")
    .then(response => response.json())
    .then(data => {
      console.log("New data:", data);
    })
    .catch(error => {
      console.error("Polling error:", error);
    });
}

setInterval(fetchUpdates, POLL_INTERVAL);


---

Better Example (Recommended pattern)

- While many beginners use setInterval, the professional way to do it is using a recursive setTimeout.

- Why? If the server is slow and a request takes 4 seconds, but your setInterval is set to 3 seconds, you will start "stacking" requests, leading to a race condition or a browser crash. 
- Recursive setTimeout ensures the next poll only starts after the previous one finishes.

async function pollData() {
  try {
    const response = await fetch('/api/status');
    const data = await response.json();
    
    console.log("Data received:", data);

    // If the job is done, stop polling
    if (data.status === 'COMPLETED') {
      console.log("Processing finished!");
      return; 
    }

  } catch (error) {
    console.error("Polling failed:", error);
  } finally {
    // Schedule the next request ONLY after this one is done
    // This prevents request stacking
    setTimeout(pollData, 5000); 
  }
}

// Start polling
pollData();

> Total gap for next request = response time + settimeout_delay

---

> Best Practices:

- Choose the right interval
* Too small â†’ server overload
* Too large â†’ slow updates

- Exponential Backoff
If the server keeps saying "no new data," stop asking so often. Increase the interval from 5s â†’ 10s â†’ 30s â†’ 60s. This saves battery and server costs.

- Thundering herd: If you have 10,000 users and your server goes down for a minute, when it comes back up, all 10,000 users will poll at the exact same millisecond.
Solution: Add a small random delay (e.g., 5000 + Math.random() * 1000) to your interval so requests are "staggered."

- Stop polling when not needed
* Tab hidden
* User logged out
* Component unmounted

- Handle errors gracefully
* Retry with delay
* Avoid infinite rapid retries

- Use polling only when necessary
* Prefer WebSockets or SSE if available

- Backend optimization
* Send minimal payload
* Use caching headers if possible

---

Short Polling vs Long Polling (Quick hint)

* Short polling: client waits â†’ asks again
* Long polling: server waits â†’ responds when data changes

---

Quick Check (1 question only ðŸ‘‡)

If your app needs instant chat messages, would short polling be a good choice?
Why or why not?

No.


---


> Example with Exponential backoff and solution to Thundering herd.


/**
 * Short Polling with Exponential Backoff and Jitter
 */
async function pollWithBackoff() {
  const CONFIG = {
    BASE_DELAY: 1000,    // Start with 1 second
    MAX_DELAY: 30000,    // Max out at 30 seconds
    FACTOR: 2,           // Double the delay each time
    JITTER_RANGE: 1000   // Max random milliseconds to add
  };

  let currentDelay = CONFIG.BASE_DELAY;

  async function executePoll() {
    try {
      const response = await fetch('https://api.example.com/status');
      const data = await response.json();

      // Scenario A: Goal reached - Stop polling
      if (data.status === 'COMPLETED') {
        console.log("Task finished:", data);
        return; 
      }

      // Scenario B: Data hasn't changed - Increase backoff
      if (!data.hasUpdates) {
        console.log(`No updates. Increasing delay to ${currentDelay}ms`);
        currentDelay = Math.min(currentDelay * CONFIG.FACTOR, CONFIG.MAX_DELAY);
      } 
      
      // Scenario C: Data updated - Reset backoff
      else {
        console.log("Data received!", data);
        currentDelay = CONFIG.BASE_DELAY;
      }

    } catch (error) {
      console.error("Poll failed, backing off...", error);
      currentDelay = Math.min(currentDelay * CONFIG.FACTOR, CONFIG.MAX_DELAY);
    } finally {
      // Apply Jitter to prevent "Thundering Herd" problem
      const jitter = Math.random() * CONFIG.JITTER_RANGE;
      
      setTimeout(executePoll, currentDelay + jitter);
    }
  }

  executePoll();
}

// Start the process
pollWithBackoff();