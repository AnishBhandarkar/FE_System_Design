Server-Sent Events (SSE) is a standard that allows servers to push real-time updates to web pages over a single, long-lived HTTP connection. If WebSockets are a "two-way street," SSE is a "one-way megaphone" where the server talks and the client listens.

---

1. When is it needed?

SSE is the perfect choice for scenarios where data only needs to flow from the server to the client.

* Live Feeds: Twitter/X timelines, news tickers, or sports scores.
* Dashboards: Real-time server monitoring or stock price updates.
* AI Streaming: Word-by-word text generation (like ChatGPT).
* In-App Notifications: A "bell" icon that lights up when you get a new alert.

- Both client and server can end connection.

---

2. Pros and Cons

Pros:
- Standard HTTP: Works over existing infrastructure, firewalls, and proxies.
- Auto-Reconnect: Browsers automatically attempt to reconnect if the line drops.
- Lightweight: No complex "handshakes" like WebSockets; very low CPU/RAM overhead.
- Native Support: The EventSource API is built into all modern browsers.
- Efficient for one-way data streaming

Cons:
- Unidirectional: The client cannot send data back over the same stream (must use a separate POST).
- Connection Limits: Limited to 6 connections per domain if using HTTP/1.1.
- UTF-8 Only: Optimized for text; sending binary data (like images) requires Base64 encoding.
- No IE Support: (Though rare now, it requires a polyfill for Internet Explorer).
- Each client opens a persistent connection → can be heavy for many clients

---

3. Implementation in JavaScript

> Server-Side (Node.js/Express)

The key to SSE is setting the correct headers and keeping the response "open" without ever calling `res.end()`.


const express = require('express');
const app = express();

app.get('/events', (req, res) => {
  // 1. Set required headers for SSE
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
  });

  // 2. Function to format data into the SSE protocol
  // Format must be: "data: <message>\n\n"
  const sendUpdate = (data) => {
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  // Send an initial heartbeat
  sendUpdate({ message: 'Connected to live stream' });

  // 3. Simulate periodic updates
  const intervalId = setInterval(() => {
    sendUpdate({ time: new Date().toLocaleTimeString(), status: 'OK' });
  }, 3000);

  // 4. Clean up when client disconnects
  req.on('close', () => {
    clearInterval(intervalId);
    res.end();
  });
});

app.listen(3000, () => console.log('SSE Server on port 3000'));



> Client-Side (Native Browser API)

The browser uses the `EventSource` interface, which is extremely simple.

const eventSource = new EventSource('/events');

// Listen for generic messages
eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log("New Update:", data);
};

// Listen for specific named events (if defined by server)
eventSource.addEventListener('update', (event) => {
  console.log("Custom event:", event.data);
});

// Error handling (Auto-reconnect is built-in)
eventSource.onerror = (err) => {
  console.error("EventSource failed:", err);
};


// close connection
eventSource.close();



---

4. Key Challenges & Explanations

A. The "Connection Limit" Bottleneck:

If your site is running on HTTP/1.1, browsers limit you to 6 open connections per domain. If a user opens 7 tabs of your app, the 7th tab won't be able to load any images, CSS, or the SSE stream.

* The Fix: Use HTTP/2. Under HTTP/2, the "6-connection limit" disappears because multiple streams are multiplexed over a single TCP connection.

-

B. Proxy & Load Balancer Buffering:

Some proxies (like Nginx) or security layers try to "buffer" responses to be efficient. Because SSE is a never-ending stream, the proxy might wait until it has "enough" data before sending it to the client, causing massive delays.

* The Fix: Disable buffering for the SSE endpoint. In Nginx, you use the header `X-Accel-Buffering: no`.

-

C. Authentication Issues:

The native `EventSource` API does not support custom HTTP headers. This makes it hard to send an `Authorization: Bearer <token>` header.

* The Fix: 1.  Pass the token as a query parameter: `/events?token=xyz`.
2.  Use a "Cookie-based" authentication.
3.  Use a library like `fetch-event-source` which polyfills SSE using the `fetch` API, allowing custom headers.

-

D. Timeouts:

If no data is sent for a long time, some firewalls or load balancers will assume the connection is dead and kill it.

* The Fix: Implement a "Heartbeat." Have the server send an empty comment (e.g., `:\n\n`) every 15–30 seconds to keep the line active.

---

Summary Comparison

| Feature        | Long Polling   | SSE            | WebSockets |
| -------------- | -------------- | -------------- | --- |
| Direction      | Unidirectional | Unidirectional | Bidirectional |
| Protocol       | HTTP           | HTTP           | WebSocket (Upgrade) |
| Ease of Setup  | Moderate       | Easy           | Complex |
| Auto-Reconnect | No (Manual)    | Yes (Native)   | No (Manual) |
 